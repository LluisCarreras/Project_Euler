# -*- coding: utf-8 -*-
"""
Created on Sun Jan 31 13:36:01 2016

@author: Lluís Carreras González

Cyclical figurate numbers
Problem 61

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers 
are all figurate (polygonal) numbers and are generated by the following 
formulae:

Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Square	 	P4,n=n2	 	1, 4, 9, 16, 25, ...
Pentagonal	 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
Heptagonal	 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...
The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three 
interesting properties.

The set is cyclic, in that the last two digits of each number is the first 
two digits of the next number (including the last number with the first).

Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and 
pentagonal (P5,44=2882), is represented by a different number in the set.

This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which 
each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, 
and octagonal, is represented by a different number in the set.
"""


def create_polygonal(function, num_digits):
    """
    Return a list with all the polygonal numbers obtained with the given
    formula, with the number of digits num_digits.
    """
    results = []
    num = 1
    len_num = 1
    while len_num <= num_digits:
        result = function(num)
        if len(str(result)) == num_digits:
            results.append(result)
        num += 1
        len_num = len(str(num))
    return results
    
    
p3_function = lambda n: int(n * (n + 1) / 2)
p4_function = lambda n: int(n * n)
p5_function = lambda n: int(n * (3 * n - 1) / 2)
p6_function = lambda n: int(n * (2 * n - 1))
p7_function = lambda n: int(n * (5 * n - 3) / 2)
p8_function = lambda n: int(n * (3 * n - 2))

p3_values = create_polygonal(p3_function, 4)
p4_values = create_polygonal(p4_function, 4)
p5_values = create_polygonal(p5_function, 4)
p6_values = create_polygonal(p6_function, 4)
p7_values = create_polygonal(p7_function, 4)
p8_values = create_polygonal(p8_function, 4)

pn_lists = [p3_values, p4_values, p5_values, p6_values, p7_values, p8_values]


all_p_dict = {}
all_v_dict = {}
for pn_lists_idx in range(6):
    for pn_value in pn_lists[pn_lists_idx]:
        if pn_value in all_p_dict:
            all_p_dict[pn_value].append(pn_lists_idx + 3)
        else:
            all_p_dict[pn_value] = [pn_lists_idx + 3]
        if pn_lists_idx + 3 in all_v_dict:
            all_v_dict[pn_lists_idx + 3].append(pn_value)
        else:
            all_v_dict[pn_lists_idx + 3] = [pn_value]


first_digs = {v // 100 for p in pn_lists for v in p}
last_digs = {v % 100 for p in pn_lists for v in p}
intersec = first_digs.intersection(last_digs)

feasible_nums = [n * 100 + m for n in intersec for m in intersec]

feasible_dict = {k:v for k,v in all_p_dict.items() if k in feasible_nums}

print(feasible_dict)
print(all_v_dict)



#def cyclical():
#    for p3 in p3_values:
#        for p4 in p4_values:
#            print(p3, "\t", p4)
#            for p5 in p5_values:
#                for p6 in p6_values:
#                    for p7 in p7_values:
#                        for p8 in p8_values:
#                            test_list = [p3, p4, p5, p6, p7, p8]
#                            two_first_digs = sorted([p // 100 for p in test_list])
#                            two_last_digs = sorted([p % 100 for p in test_list])
##                            print(test_list, "\t", two_first_digs, "\t", two_last_digs)
#                            if two_first_digs == two_last_digs:
#                                return test_list, sum(test_list)
#    return -1
#
#
#print(cyclical())










#print(all_p_dict)
    



    